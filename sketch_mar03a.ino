#include <Thread.h>                                                 // Библиотека работы с потоками
#include <Servo.h>                                                  // Библиотека работы с сервоприводом
#include <Ultrasonic.h>                                             // Библиотека работы с ультразвуковым датчиком

Thread sonicThread = Thread();                                      // Инициализация потока ультразвукового датчика
Ultrasonic ultrasonic(12, 9);                                       // Инициализация ультразвукового датчика
float dist_arr[30];                                                 // Массив для усреднения показаний датчика
int num;                                                            // Счётчик массива

enum states {                                                       // Перечисление состояний сервопривода
  STATE_0,                                                          // Режим локатора
  STATE_1,                                                          // Поворот на 32 градуса
  STATE_2,                                                          // Поворот на 46 градусов
  STATE_3,                                                          // Поворот на 60 градусов
  STATE_4,                                                          // Поворот на 74 градуса
  STATE_5,                                                          // Поворот на 88 градусов
  STATE_6,                                                          // Поворот на 102 градуса
  STATE_7,                                                          // Поворот на 116 градусов
  STATE_8,                                                          // Поворот на 130 градусов
  STATE_9                                                           // Поворот на 144 градуса
};

class ServoClass {                                                  // Расширенный класс сервопривода
  Servo servo;                                                      // Инициализация сервопривода
  int servPosition;                                                 // Текущая позиция сервопривода, deg
  int posMax;                                                       // Максимально допустимая позиция сервопривода, deg
  int posMin;                                                       // Минимально допустимая позиция сервопривода, deg
  int posInit;                                                      // Исходная позиция сервопривода, градусов

  boolean move;                                                     // Индикатор движения сервопривода
  int movePosition;                                                 // Конечная позиция сервопривода, deg
  float moveSpeed;                                                  // Скорость движения сервопривода, об/мин
  int moveInterval;                                                 // Интервал между движениями при заданной скорости, мс
  int moveIncrement;                                                // Изменение позиции сервопривода за 1 интервал времени, deg
  unsigned long lastTime;                                           // Время последнего движения сервопривода, мс (от начала работы программы)
  
  public:
  states state;                                                     // Объявление перечисления для сервопривода
  ServoClass () {                                                   // Конструктор класса
    posMax = 180;
    posMin = 0;
    posInit = 90;
    servPosition = 90;
    lastTime = millis();
  }

  void AttachServo (int pin, int minpos, int maxpos, int initpos) { // Расширенная функция подключения сервопривода с указанием исходной позиции
    servo.attach(pin);                                              // Подключение сервопривода к указанному пину
    posMax = maxpos;                                                // Установка максимальной позиции 
    posMin = minpos;                                                // Установка минимальной позиции 
    posInit = initpos;                                              // Установка исходной позиции
    servPosition = posInit;                                         // Позиция сервопривода должна сответствовать исходному положению 
    servo.write(servPosition);                                      // Команда изменить положение
  }


  void AttachServo (int pin, int minpos, int maxpos) {              // Расширенная функция подключения сервопривода без указания исходной позиции
    servo.attach(pin);                                              // Подключение сервопривода к указанному пину
    posMax = maxpos;                                                // Установка максимальной позиции 
    posMin = minpos;                                                // Установка минимальной позиции 
    posInit = minpos;                                               // Установка исходной позиции
    servPosition = posInit;                                         // Позиция сервопривода должна сответствовать исходному положению 
    servo.write(servPosition);                                      // Команда изменить положение
  }

  int PositionCheck(int movePos) {                                  // Функция проверки валидности конечной позиции
    int checkedPos;
    if (movePos <= posMin) {                                        // Проверка по минимальной границе
      checkedPos = posMin;
    } else if (movePos >= posMax) {                                 // Проверка по максимальной границе
      checkedPos = posMax;
    } else checkedPos = movePos;                                    // Установка значения при прохождении проверок
  
    return checkedPos;
  }

  void MoveTo (int movePos) {                                       // Функция движения сервопривода на стандартной скорости
    movePosition = PositionCheck(movePos);                          // Проверка валидности
    servo.write(movePosition);                                      // Изменение положения
  }

  void MoveTo (int movePos, float speed) {                          // Функция настройки параметров движения сервопривода на заданной скорости
    movePosition = PositionCheck(movePos);                          // Проверка валидности
    moveSpeed=speed;                                                // Установка скорости сервопривода
    int angle=abs(movePosition-servPosition);                       // Угол перемещения сервопривода 
    if (movePosition >= servPosition) {                             // Определение направления движения (на 1 градус вперёд или назад)
      moveIncrement = 1;                                            
    } else {
      moveIncrement = -1;
    }
    float rotationSpeed = moveSpeed*360/60;                         // Первод скорости из оборотов в минуту в градусы в секунду
    moveInterval = (int)1000/rotationSpeed;                         // Вычисление интервала времени между перемещениями на один градус, мс
    move=true;                                                      // Команда начать плавное перемещение
  } 
  
  void MoveEternal(float speed) {                                   // Функция настройки параметров движения сервопривода на заданной скорости в режиме локатора
    moveSpeed = speed;
    float rotationSpeed = moveSpeed*360/60;                         // Первод скорости из оборотов в минуту в градусы в секунду
    moveInterval = (int)1000/rotationSpeed;                         // Вычисление интервала времени между перемещениями на один градус, мс
  }

  void Update () {                                                  // Функция движения сервопривода
    if (move) {                                                     // Проверка индикатора движения
      if ((millis() - lastTime) >= moveInterval) {                  // Проверка необходимости движения в соответствии с вычисленным периодом ожидания
        servPosition += moveIncrement;                              // Движение в ту или иную сторону в зависимости от запроса на конечную позицию
        servo.write(servPosition);                                  // Команда сервоприводу с новой позицией
        lastTime = millis();                                        // Обновление счетчика времени для следующей итерации
        if (servPosition == movePosition) {                         // Прекращение движения при достижении необходимой позиции
          move = false;
        }
      }
    }
  }

  void UpdateEternal() {                                            // Функция движения сервопривода в режиме локатора
    if ((millis() - lastTime) >= moveInterval) {                    // Проверка необходимости движения в соответствии с вычисленным периодом ожидания
      servPosition += moveIncrement;                                // Движение в ту или иную сторону в зависимости от запроса на конечную позицию
      servo.write(servPosition);                                    // Команда сервоприводу с новой позицией
      lastTime = millis();                                          // Обновление счетчика времени для следующей итерации
      if (servPosition == posMax)                                   // Изменение направления движения при достижении максимальной позиции
        moveIncrement = -1;
      if (servPosition == posMin)                                   // Изменение направления движения при достижении минимальной позиции
        moveIncrement = 1;
      }
    }

  void write(int angle) {
    servo.write(angle);
  }
};

ServoClass servo;                                                   // Сервопривод камеры

void setup() {
  servo.AttachServo(10, 10, 144);                                   // Подключение сервопривода к 10 пину с пределами перемещения от 10 до 140 градусов
  servo.MoveEternal(4);                                             // Включение режима локатора со скоростью вращения 4 оборота в минуту
  
  sonicThread.onRun(dist);                                          // Назначение потоку ультразвукового датчика задачи
  sonicThread.setInterval(10);                                      // Установка интервала обновления потока
  
  Serial.begin(9600);                                               // Открытие Serial порта со скоростью 9600 бод
}

void loop() {
  switch (servo.state) {                                            // Движение сервопривода в зависимости от состояния
    case STATE_0:
      servo.UpdateEternal();
      break;
    case STATE_1:
      servo.write(32);
      break;
    case STATE_2:
      servo.write(46);
      break;
    case STATE_3:
      servo.write(60);
      break;
    case STATE_4:
      servo.write(74);
      break;
    case STATE_5:
      servo.write(88);
      break;
    case STATE_6:
      servo.write(102);
      break;
    case STATE_7:
      servo.write(116);
      break;
    case STATE_8:
      servo.write(130);
      break;
    case STATE_9:
      servo.write(144);
      break;
  }
  
  if (sonicThread.shouldRun()) {                                    // Проверка необходимости работы потока ультразвукового датчика
    sonicThread.run(); 
  }
}

void dist() {                                                       // Задача потока ультразвукового датчика
  float dist_cm = ultrasonic.Ranging(CM);                           // Снятие текущих показаний датчика
  if ((dist_cm > 15) && (dist_cm < 300)) {                          // Первоначальная обработка ошибок датчика
  dist_arr[num] = dist_cm;                                          // Внесение валидных показаний в общий массив для последующих этапов обработки ошибок
  if (num == 29) {                                                  // Выполнение усреднения показаний по интервалу времени при заполнении массива
    num = 0;                                                        // Обнуление счётчика итераций для начала следующего интервала времени
    int numb;                                                       // Переменная, содержащая итоговое количество значений после завершения всех проверок
    float dist_sr;                                                  // Переменная, содержащая усреднённые показания за интервал времени (~300 мс)
    float dist_min = dist_arr[0];                                   // Присвоение нулевому элементу массива минимального значения из первых 5 (исключение ошибок датчика для нулевого элемента)
    for (int i = 1; i < 5; i++) {
      if (dist_arr[i] < dist_min) dist_min = dist_arr[i];
    }
    dist_arr[0] = dist_min;
    dist_sr = dist_arr[0];                                          // Суммирование всех показаний за интервал времени для последующего усреднения
    numb++;                                                         // Увеличение счётчика итогового количества значений
    for (int i = 1; i < 30; i++) {                                  // Проверка попадания значения в определённый интервал относительно предыдущего значения (исключение ошибок для ненулевых элементов)
      if ((dist_arr[i] < dist_arr[i-1] + 15) && (dist_arr[i] > dist_arr[i-1] - 15)) {
        dist_sr += dist_arr[i];
        numb++;
      }
    }
    dist_sr = dist_sr/numb;                                         // Вычисление усреднённого значения
    Serial.println(dist_sr);                                        // Вывод усреднённого значения за интервал и начало нового интервала
    if ((dist_sr >= 15) && (dist_sr < 26)) {                        // Определение состояния сервопривода
      servo.state = STATE_1;
    }
    if ((dist_sr >= 26) && (dist_sr < 45.5)) {
      servo.state = STATE_2;
    }
    if ((dist_sr >= 45.5) && (dist_sr < 61.4)) {
      servo.state = STATE_3;
    }
    if ((dist_sr >= 61.4) && (dist_sr < 75.7)) {
      servo.state = STATE_4;
    }
    if ((dist_sr >= 75.7) && (dist_sr < 90.4)) {
      servo.state = STATE_5;
    }
    if ((dist_sr >= 90.4) && (dist_sr < 103.6)) {
      servo.state = STATE_6;
    }
    if ((dist_sr >= 103.6) && (dist_sr < 119.5)) {
      servo.state = STATE_7;
    }
    if ((dist_sr >= 119.5) && (dist_sr < 139)) {
      servo.state = STATE_8;
    }
    if ((dist_sr >= 139) && (dist_sr < 150)) {
      servo.state = STATE_9;
    }
    if (dist_sr >= 150){
      servo.state = STATE_0;
    }
  } else num++;                                                     // Увеличение счётчика итераций, если итерация не последняя за интервал времени
  }
}

/* Делается допущение, что за интервал времени ~300 мс объект не может сильно изменить своё положение.
 * Поэтому сильные изменения положения объекта принимаются за ошибки, так как датчик иногда выдаёт неправдоподобные значения даже для неподвижного объекта.
 * Реальные изменения положения объекта всегда учитываются на следующих интервалах времени при перезаписи массива показаний датчика.
 * Периодичность вывода усреднённых показаний равна ~300 мс, определение точной периодичности для каждого интервала времени требует нецелесообразного изменения логики программы.
 * Приблизительной оценки периодичности достаточно, так как погрешность в пару десятков миллисекунд не отразится на плавности работы программы.
 * Оценка является приблизительной, т.к. время от времени датчик даёт неправдоподобные показания (30 м при общих размерах помещения не более, чем 6x6 м, или 5 см при отсутствии объектов вблизи датчика).
 * При первоначальной проверке на валидность показаний отсеиваются показания менее 15 см и более 300 см (3 м) в связи с планировкой помещения.
 * Значения снимаются каждые 10 мс, но лишние показания отсеиваются, поэтому на заполнение массива значений требуется несколько больше времени.
 */
